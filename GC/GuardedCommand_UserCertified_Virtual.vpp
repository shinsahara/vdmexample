\section{ガードコマンド\_利用者\_認証\_仮想世界}
利用者が認証された場合を記述した仮想世界用ガードコマンド。

\begin{vdm_al}
class ガードコマンド_利用者_認証_仮想世界 is subclass of ガードコマンド_利用者

operations
public ガードコマンド_利用者_認証_仮想世界 : 場所グラフ`場所ID ==> ガードコマンド_利用者_認証_仮想世界
ガードコマンド_利用者_認証_仮想世界(a場所ID) == (
	s場所ID := a場所ID
);
\end{vdm_al}

\subsection{ガードコマンド\_利用者\_認証\_仮想世界のcheck}
利用者の認証をID端末に依頼する。

認証結果は、更新黒板属性の仮想世界利用者居場所DBに設定する。

\begin{vdm_al}
public check : 黒板 ==> ()
check (a大域黒板) == (
	def mk_(w黒板属性DB, w更新黒板属性DB) = a大域黒板.得る() in
	s局所黒板.全属性を設定する(w黒板属性DB, w更新黒板属性DB);
	def mk_(w黒板属性DB, -) = s局所黒板.得る();
		w場所グラフ = s局所黒板.s場所グラフ;
		w仮想利用者のいる場所DB = w黒板属性DB(mk_token("仮想世界利用者居場所"));
		w利用者のいる場所DB = w黒板属性DB(mk_token("実際の利用者居場所"));
		w利用者の居場所ID = s場所ID;
		w利用者集合 = dom (w利用者のいる場所DB :> {w利用者の居場所ID}); --この場所(w利用者の居場所ID)にいる利用者の集合
		w仮想利用者集合 = dom (w仮想利用者のいる場所DB :> {w利用者の居場所ID}) --この場所(w利用者の居場所ID)にいる利用者の集合
	in (
	if w利用者集合 = {} then return;
	def {w利用者} = w利用者集合 in (
	if w場所グラフ.ID端末がある(w利用者の居場所ID) and not 利用者集合に含まれている(w仮想利用者集合, w利用者) then (
		s局所黒板.更新黒板属性を設定する(mk_token("仮想世界利用者居場所"), {w利用者|-> w利用者の居場所ID});
		def - = debug >= 5 => new IO().echo(
				"\n実際の利用者が認証を依頼したので、仮想世界利用者居場所に登録します。" ^
				VDMUtil`val2seq_of_char[利用者 * 場所グラフ`場所ID]
					(mk_(w利用者,  w利用者の居場所ID)) ^
				"\n") 
		in skip
	) --if
	) -- def in
	) --def in
)
pre
	let mk_(w黒板属性DB, -) = a大域黒板.得る(),
		w利用者のいる場所DB = w黒板属性DB(mk_token("実際の利用者居場所")),
		w利用者の居場所ID = s場所ID,
		w利用者集合 = dom (w利用者のいる場所DB :> {w利用者の居場所ID}) --この場所(w利用者の居場所ID)にいる利用者の集合
	in
	card w利用者集合 in set {0, 1}
;
\end{vdm_al}

\subsection{ガードコマンド\_利用者\_認証\_仮想世界のupdate}
局所黒板のID端末DBと仮想世界利用者居場所DBを大域黒板に設定する。

\begin{vdm_al}
public update : 黒板 ==> ()
update(a大域黒板) == 
	def w更新黒板属性DB = s局所黒板.更新黒板属性を得る();
		w更新仮想世界利用者居場所DB = w更新黒板属性DB(mk_token("仮想世界利用者居場所"))
	in (
	a大域黒板.設定する(mk_token("仮想世界利用者居場所"), w更新仮想世界利用者居場所DB);
);

end ガードコマンド_利用者_認証_仮想世界
\end{vdm_al}

\begin{rtinfo}
{vdm.tc}[ガードコマンド_利用者_認証_仮想世界]
\end{rtinfo}